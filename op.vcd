$date
	Thu May 18 02:21:27 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module tb_Processor $end
$var reg 1 ! clk1 $end
$var reg 1 " clk2 $end
$scope module dut $end
$var wire 1 ! clk1 $end
$var wire 1 " clk2 $end
$var wire 1 # rst $end
$var wire 2 $ cond [1:0] $end
$var wire 16 % EX_MEM_ALUOut [15:0] $end
$var reg 16 & Acc [15:0] $end
$var reg 10 ' EX_MEM_Add [9:0] $end
$var reg 16 ( EX_MEM_IR [15:0] $end
$var reg 1 ) HLT $end
$var reg 16 * ID_EX_A [15:0] $end
$var reg 16 + ID_EX_IR [15:0] $end
$var reg 16 , IF_ID_IR [15:0] $end
$var reg 16 - PC [15:0] $end
$var reg 1 . TAKEN_BRANCH $end
$var reg 1 / Wrt $end
$var reg 6 0 cb_EX [5:0] $end
$var reg 6 1 cb_ID [5:0] $end
$scope module func $end
$var wire 1 2 f $end
$var wire 1 3 no $end
$var wire 1 4 nx $end
$var wire 1 5 ny $end
$var wire 16 6 x [15:0] $end
$var wire 16 7 x1 [15:0] $end
$var wire 16 8 y [15:0] $end
$var wire 16 9 y1 [15:0] $end
$var wire 1 : zx $end
$var wire 1 ; zy $end
$var wire 17 < f2 [16:0] $end
$var wire 17 = f1 [16:0] $end
$var reg 1 > ng $end
$var reg 16 ? o [15:0] $end
$var reg 1 @ zr $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
x@
bx ?
x>
bx =
bx <
x;
x:
bx 9
bx 8
bx 7
bx 6
x5
x4
x3
x2
bx 1
bx 0
0/
0.
b0 -
bx ,
bx +
bx *
0)
b0 (
bx '
bx &
bx %
bx $
z#
0"
0!
$end
#1
b1 -
b101000000000110 ,
1!
#2
1.
b101000000000110 +
1"
#3
0!
#4
0"
#5
0.
b10100000000000 -
1!
#6
1.
1"
#7
0!
#8
0"
#9
0.
1!
#10
1.
1"
#11
0!
#12
0"
#13
0.
1!
#14
1.
1"
#15
0!
#16
0"
#17
0.
1!
#18
1.
1"
#19
0!
#20
0"
